name: Release Orchestrator

# ç›‘æ§æ‰€æœ‰å‘å¸ƒå·¥ä½œæµï¼Œå½“å…¨éƒ¨å®Œæˆåè§¦å‘éªŒè¯
on:
  workflow_run:
    workflows: 
      - "Release Desktop App"
    types:
      - completed

jobs:
  wait-and-verify:
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success'
    permissions:
      actions: read
      contents: read
    
    steps:
      - name: Extract version from triggering workflow
        id: version
        uses: actions/github-script@v8
        with:
          script: |
            // ä»è§¦å‘çš„å·¥ä½œæµè·å–ç‰ˆæœ¬
            const run = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.payload.workflow_run.id
            });
            
            // ä» ref æå–ç‰ˆæœ¬ (desktop-v0.1.70 -> 0.1.70)
            const ref = run.data.head_branch || context.payload.workflow_run.head_branch;
            let version = '';
            
            if (ref && ref.startsWith('desktop-v')) {
              version = ref.replace('desktop-v', '');
            } else {
              // å°è¯•ä» tag è·å–
              const tags = await github.rest.repos.listTags({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 1
              });
              if (tags.data.length > 0 && tags.data[0].name.startsWith('desktop-v')) {
                version = tags.data[0].name.replace('desktop-v', '');
              }
            }
            
            console.log(`ğŸ“¦ Version: ${version}`);
            core.setOutput('version', version);
            return version;

      - name: Wait for all publish workflows
        id: wait
        uses: actions/github-script@v8
        with:
          script: |
            const version = '${{ steps.version.outputs.result }}';
            if (!version) {
              console.log('âš ï¸ Could not determine version, skipping');
              return false;
            }
            
            // éœ€è¦ç­‰å¾…çš„å·¥ä½œæµåˆ—è¡¨
            const publishWorkflows = [
              'snap-publish.yml',
              'flatpak-publish.yml',
              'aur-publish.yml',
              'aur-bin-publish.yml',
              'winget-publish.yml',
              'scoop-publish.yml',
              'chocolatey-publish.yml',
              'homebrew-publish.yml'
            ];
            
            const maxWaitMinutes = 60;  // æœ€å¤šç­‰å¾… 60 åˆ†é’Ÿ
            const checkIntervalSeconds = 60;  // æ¯ 60 ç§’æ£€æŸ¥ä¸€æ¬¡
            const maxChecks = (maxWaitMinutes * 60) / checkIntervalSeconds;
            
            console.log(`â³ Waiting for ${publishWorkflows.length} publish workflows to complete...`);
            console.log(`   Max wait time: ${maxWaitMinutes} minutes`);
            console.log(`   Check interval: ${checkIntervalSeconds} seconds`);
            
            // ç­‰å¾…ä¸€æ®µæ—¶é—´è®©å·¥ä½œæµå¯åŠ¨
            console.log('\nâ³ Waiting 2 minutes for workflows to start...');
            await new Promise(resolve => setTimeout(resolve, 120000));
            
            let allCompleted = false;
            let checkCount = 0;
            
            while (!allCompleted && checkCount < maxChecks) {
              checkCount++;
              console.log(`\nğŸ” Check ${checkCount}/${maxChecks}...`);
              
              const workflowStatus = {};
              let pendingCount = 0;
              let completedCount = 0;
              let failedCount = 0;
              
              for (const workflowFile of publishWorkflows) {
                try {
                  // è·å–æœ€è¿‘çš„å·¥ä½œæµè¿è¡Œ
                  const runs = await github.rest.actions.listWorkflowRuns({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    workflow_id: workflowFile,
                    per_page: 5,
                    created: `>=${new Date(Date.now() - 3600000).toISOString()}`  // æœ€è¿‘ 1 å°æ—¶
                  });
                  
                  if (runs.data.workflow_runs.length === 0) {
                    workflowStatus[workflowFile] = 'not_started';
                    pendingCount++;
                  } else {
                    const latestRun = runs.data.workflow_runs[0];
                    workflowStatus[workflowFile] = latestRun.status === 'completed' 
                      ? latestRun.conclusion 
                      : latestRun.status;
                    
                    if (latestRun.status === 'completed') {
                      if (latestRun.conclusion === 'success') {
                        completedCount++;
                      } else {
                        failedCount++;
                      }
                    } else {
                      pendingCount++;
                    }
                  }
                } catch (error) {
                  workflowStatus[workflowFile] = 'error';
                  console.log(`  âš ï¸ ${workflowFile}: ${error.message}`);
                }
              }
              
              // æ‰“å°çŠ¶æ€
              console.log('\nğŸ“Š Workflow Status:');
              for (const [workflow, status] of Object.entries(workflowStatus)) {
                const icon = status === 'success' ? 'âœ…' : 
                             status === 'failure' ? 'âŒ' : 
                             status === 'in_progress' || status === 'queued' ? 'ğŸ”„' : 'â³';
                console.log(`  ${icon} ${workflow}: ${status}`);
              }
              
              console.log(`\nğŸ“ˆ Summary: ${completedCount} completed, ${failedCount} failed, ${pendingCount} pending`);
              
              // æ£€æŸ¥æ˜¯å¦å…¨éƒ¨å®Œæˆ
              if (pendingCount === 0) {
                allCompleted = true;
                console.log('\nâœ… All workflows completed!');
              } else {
                console.log(`\nâ³ Waiting ${checkIntervalSeconds} seconds before next check...`);
                await new Promise(resolve => setTimeout(resolve, checkIntervalSeconds * 1000));
              }
            }
            
            if (!allCompleted) {
              console.log('\nâš ï¸ Timeout reached, some workflows may still be running');
            }
            
            return allCompleted;

      - name: Trigger verification workflow
        if: steps.version.outputs.result != ''
        uses: actions/github-script@v8
        with:
          script: |
            const version = '${{ steps.version.outputs.result }}';
            
            console.log(`ğŸš€ Triggering verification workflow for version ${version}...`);
            
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'install-verify.yml',
                ref: 'main',
                inputs: {
                  version: version,
                  platforms: 'all',
                  wait_minutes: '5'  // ç­‰å¾… 5 åˆ†é’Ÿè®©åŒ…åˆ†å‘
                }
              });
              console.log('âœ… Verification workflow triggered successfully!');
            } catch (error) {
              console.log(`âš ï¸ Failed to trigger verification: ${error.message}`);
            }
