# 固定侧边栏滚动布局优化方案

## 📋 方案概述

实现了**中间内容区域滚动，两侧侧边栏固定**的布局方案，提供更好的阅读体验和导航体验。

## 🎯 核心设计

### 布局结构

```
┌─────────────────────────────────────────┐
│           Header (固定)                  │
├──────────┬──────────────────┬───────────┤
│          │                  │           │
│  左侧    │   中间内容区域    │  右侧     │
│  导航    │   (独立滚动)      │  目录     │
│  (固定)  │                  │  (固定)   │
│          │                  │           │
│          │  ← 只有这里滚动  │           │
│          │                  │           │
└──────────┴──────────────────┴───────────┘
```

### 实现原理

1. **左侧导航栏**：使用 `fixed` 定位，固定高度 `h-[calc(100vh-4rem)]`
2. **中间内容区**：使用 `overflow-y-auto` 实现独立滚动，固定高度
3. **右侧目录**：使用 `fixed` 定位，固定高度
4. **间距控制**：使用 `ml-64` 和 `xl:mr-64` 为固定侧边栏留出空间

## 🚀 优化特性

### 1. 固定侧边栏

#### 左侧导航栏
- ✅ 固定定位，不随内容滚动
- ✅ 高度自适应：`calc(100vh - 4rem)`（减去 header 高度）
- ✅ 内部可滚动（导航项过多时）
- ✅ 移动端支持滑动切换

#### 右侧目录
- ✅ 固定定位，不随内容滚动
- ✅ 仅在 xl 屏幕（≥1280px）显示
- ✅ 自动高亮当前章节
- ✅ 点击跳转到对应章节

### 2. 中间内容区域

- ✅ 独立滚动，不影响侧边栏
- ✅ 平滑滚动效果
- ✅ 自定义滚动条样式
- ✅ 滚动性能优化（`overscroll-contain`）

### 3. 滚动优化

#### 滚动监听优化
- ✅ 监听内容区域的滚动（而非 window）
- ✅ 使用 `requestAnimationFrame` 优化性能
- ✅ 节流处理，减少计算频率

#### 锚点跳转优化
- ✅ 计算相对于滚动容器的位置
- ✅ 平滑滚动到目标位置
- ✅ 自动更新 URL hash

#### 进度条优化
- ✅ 基于内容区域滚动计算进度
- ✅ 实时更新，流畅动画

### 4. 移动端适配

- ✅ 移动端侧边栏可滑动切换
- ✅ 触摸优化
- ✅ 响应式布局

## 📐 技术实现

### 布局结构

```tsx
<div className="flex relative">
  {/* 左侧导航 - fixed */}
  <aside className="fixed left-0 top-16 h-[calc(100vh-4rem)]">
    <DocNav />
  </aside>

  {/* 中间内容 - 独立滚动 */}
  <main className="flex-1 lg:ml-64 xl:mr-64 h-[calc(100vh-4rem)] overflow-y-auto">
    {/* 内容 */}
  </main>

  {/* 右侧目录 - fixed */}
  <aside className="fixed right-0 top-16 h-[calc(100vh-4rem)]">
    <TableOfContents />
  </aside>
</div>
```

### 滚动监听

```tsx
// 查找内容滚动容器
const mainContent = document.querySelector('main[class*="overflow-y-auto"]');

// 监听内容区域滚动
mainContent?.addEventListener("scroll", handleScroll, { passive: true });
```

### 位置计算

```tsx
// 计算相对于滚动容器的位置
const containerRect = mainContent.getBoundingClientRect();
const elementRect = element.getBoundingClientRect();
const offsetTop = elementRect.top - containerRect.top + scrollTop;
```

## 🎨 样式优化

### 滚动条样式

- 使用 Tailwind 的 `scrollbar-thin` 插件（如已安装）
- 或使用全局 CSS 自定义滚动条样式
- 暗色模式适配

### 平滑滚动

```css
scroll-smooth {
  scroll-behavior: smooth;
}
```

### 滚动边界

```css
overscroll-contain {
  overscroll-behavior: contain;
}
```

## ⚡ 性能优化

### 1. 滚动性能

- ✅ 使用 `requestAnimationFrame` 优化滚动事件处理
- ✅ 被动事件监听器（`{ passive: true }`）
- ✅ 节流处理，减少计算频率
- ✅ 使用 `will-change` 提示浏览器优化

### 2. 渲染优化

- ✅ 固定定位减少重排
- ✅ 使用 `contain` 属性隔离渲染
- ✅ 虚拟滚动（如内容过长可考虑）

### 3. 内存优化

- ✅ 及时清理事件监听器
- ✅ 使用 `useMemo` 缓存计算结果

## 🔧 兼容性处理

### 浏览器兼容

- ✅ 现代浏览器完全支持
- ✅ 回退到 window 滚动（旧浏览器）
- ✅ 平滑滚动降级处理

### 响应式设计

```tsx
// 移动端：侧边栏可切换
lg:fixed          // 桌面端固定
lg:translate-x-0  // 桌面端显示
-translate-x-full // 移动端默认隐藏
```

## 📊 对比：优化前 vs 优化后

### 优化前 ❌

- 整个页面一起滚动
- 侧边栏随页面滚动消失
- 无法同时看到导航和内容
- 目录导航需要滚动页面才能看到

### 优化后 ✅

- 只有中间内容滚动
- 侧边栏始终可见
- 导航和目录随时可用
- 更好的阅读体验

## 🎯 使用场景

### 适合的场景

1. **长文档阅读** - 需要频繁参考导航
2. **技术文档** - 需要对比不同章节
3. **教程文档** - 需要查看目录结构
4. **参考手册** - 需要快速跳转

### 优势

- ✅ 导航始终可见，提高效率
- ✅ 目录始终可见，方便跳转
- ✅ 阅读体验更专注
- ✅ 类似专业文档网站体验

## 🔄 后续优化建议

### 短期优化

1. **滚动同步** - 侧边栏自动滚动到当前激活项
2. **滚动提示** - 顶部/底部滚动提示
3. **滚动记忆** - 记住滚动位置

### 中期优化

1. **虚拟滚动** - 超长内容优化
2. **懒加载** - 按需加载内容
3. **搜索高亮** - 搜索结果高亮

### 长期优化

1. **AI 导航** - 智能推荐相关章节
2. **阅读模式** - 聚焦阅读模式
3. **笔记功能** - 在文档中添加笔记

## 📝 注意事项

### 1. Header 高度

确保计算时使用正确的 header 高度（当前为 `4rem = 64px`）

```tsx
h-[calc(100vh-4rem)]  // 减去 header 高度
```

### 2. 侧边栏宽度

- 左侧导航：`w-64` (256px)
- 右侧目录：`w-64` (256px)
- 确保间距计算正确：`lg:ml-64 xl:mr-64`

### 3. 滚动容器

所有滚动相关的计算都需要基于内容区域，而不是 window

### 4. 移动端

移动端侧边栏使用 fixed + transform 实现滑动，注意 z-index 层级

## 🎉 总结

这个方案完美实现了**中间滚动、两侧固定**的布局需求，提供了：

- ✅ 更好的用户体验
- ✅ 更高的导航效率
- ✅ 更专业的文档展示
- ✅ 更流畅的滚动性能

该方案已集成所有滚动优化功能，可以直接使用！

